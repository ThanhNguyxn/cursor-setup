{
  "version": "1.0.0",
  "updated_at": "2024-12-02",
  "templates": {
    "golang": {
      "name": "Go",
      "description": "Go/Golang with idiomatic patterns and best practices",
      "content": "# Go Development Rules\n\nYou are an expert Go developer. Follow these guidelines for all code generation.\n\n## Code Style & Standards\n\n- Follow the official Go style guide and Effective Go\n- Use `gofmt` for formatting (never argue about style)\n- Keep line length reasonable (80-100 characters when possible)\n- Use `camelCase` for unexported, `PascalCase` for exported identifiers\n- Package names should be lowercase, single-word, no underscores\n\n## Error Handling\n\n- Always handle errors explicitly, never ignore them with `_`\n- Use `errors.Is()` and `errors.As()` for error comparison (Go 1.13+)\n- Wrap errors with context using `fmt.Errorf(\"context: %w\", err)`\n- Create custom error types for domain-specific errors\n- Return early on errors to reduce nesting\n\n```go\nif err != nil {\n    return fmt.Errorf(\"failed to process user: %w\", err)\n}\n```\n\n## Project Structure\n\n```\nproject/\n├── cmd/              # Main applications\n│   └── app/\n│       └── main.go\n├── internal/         # Private packages\n│   ├── handler/\n│   ├── service/\n│   └── repository/\n├── pkg/              # Public packages\n├── api/              # API definitions (proto, openapi)\n├── configs/          # Configuration files\n├── scripts/          # Build/deploy scripts\n├── go.mod\n└── go.sum\n```\n\n## Best Practices\n\n- Keep functions short and focused (single responsibility)\n- Use interfaces for dependencies (easier testing)\n- Accept interfaces, return concrete types\n- Use `context.Context` as the first parameter for cancellation\n- Prefer composition over inheritance\n- Use table-driven tests\n- Document exported functions and types\n\n## Concurrency\n\n- Use goroutines for concurrent operations\n- Always use channels or sync primitives for communication\n- Use `sync.WaitGroup` for waiting on multiple goroutines\n- Use `context.Context` for cancellation and timeouts\n- Avoid sharing memory; prefer message passing\n\n## Testing\n\n- Write tests in `*_test.go` files\n- Use table-driven tests for multiple cases\n- Use `testify` for assertions if needed\n- Mock interfaces, not implementations\n- Aim for high coverage on critical paths\n"
    },
    "rust": {
      "name": "Rust",
      "description": "Rust with ownership patterns and idiomatic code",
      "content": "# Rust Development Rules\n\nYou are an expert Rust developer. Follow these guidelines for all code generation.\n\n## Code Style & Standards\n\n- Follow the Rust API Guidelines and rustfmt defaults\n- Use `cargo fmt` for formatting\n- Use `cargo clippy` and address all warnings\n- Use `snake_case` for functions and variables\n- Use `PascalCase` for types, traits, and enums\n- Use `SCREAMING_SNAKE_CASE` for constants\n\n## Error Handling\n\n- Use `Result<T, E>` for recoverable errors\n- Use `panic!` only for unrecoverable errors\n- Use `?` operator for error propagation\n- Create custom error types with `thiserror`\n- Use `anyhow` for application-level errors\n\n```rust\nuse thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum AppError {\n    #[error(\"Database error: {0}\")]\n    Database(#[from] sqlx::Error),\n    #[error(\"Not found: {0}\")]\n    NotFound(String),\n}\n```\n\n## Ownership & Borrowing\n\n- Prefer borrowing (`&T`) over ownership when possible\n- Use `&mut` only when mutation is needed\n- Use `Clone` sparingly; prefer references\n- Understand and leverage the borrow checker\n- Use `Cow<'a, T>` for flexible ownership\n\n## Best Practices\n\n- Use `impl Trait` for return types when appropriate\n- Prefer iterators over manual loops\n- Use `Option<T>` instead of null/sentinel values\n- Make structs with private fields and constructor functions\n- Use builder pattern for complex construction\n- Document public APIs with `///` doc comments\n\n## Project Structure\n\n```\nproject/\n├── src/\n│   ├── main.rs       # Binary entrypoint\n│   ├── lib.rs        # Library root\n│   ├── error.rs      # Error types\n│   └── modules/\n├── tests/            # Integration tests\n├── benches/          # Benchmarks\n├── Cargo.toml\n└── Cargo.lock\n```\n\n## Testing\n\n- Unit tests in `#[cfg(test)]` modules\n- Integration tests in `tests/` directory\n- Use `#[should_panic]` for expected panics\n- Use `proptest` for property-based testing\n"
    },
    "typescript": {
      "name": "TypeScript",
      "description": "TypeScript with strict mode and modern patterns",
      "content": "# TypeScript Development Rules\n\nYou are an expert TypeScript developer. Follow these guidelines for all code generation.\n\n## Type System\n\n- Enable `strict: true` in tsconfig.json\n- Avoid `any` - use `unknown` if type is truly unknown\n- Use `interface` for object shapes (extendable)\n- Use `type` for unions, primitives, and mapped types\n- Leverage utility types: `Partial`, `Required`, `Pick`, `Omit`\n- Use generics for reusable, type-safe code\n\n```typescript\n// Prefer this\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n}\n\n// Over this\ntype User = {\n  id: string;\n  name: string;\n  email: string;\n}\n```\n\n## Best Practices\n\n- Use `const` by default, `let` when reassignment is needed\n- Never use `var`\n- Use template literals over string concatenation\n- Prefer `===` over `==`\n- Use optional chaining (`?.`) and nullish coalescing (`??`)\n- Use `readonly` for immutable properties\n- Export types/interfaces separately from implementations\n\n## Functions\n\n- Always type function parameters and return values\n- Use arrow functions for callbacks\n- Use default parameters over short-circuiting\n- Keep functions small and focused\n\n```typescript\nfunction processUser(user: User, options: ProcessOptions = {}): ProcessedUser {\n  // Implementation\n}\n```\n\n## Error Handling\n\n- Use typed errors with custom error classes\n- Handle Promise rejections properly\n- Use try/catch for async/await\n- Never swallow errors silently\n\n## Code Organization\n\n- One exported component/class per file\n- Group related functionality into modules\n- Use barrel exports (`index.ts`) for public APIs\n- Keep imports organized (external, internal, types)\n\n## Testing\n\n- Write tests with Jest or Vitest\n- Test behavior, not implementation\n- Use type-safe mocking\n- Aim for good coverage on business logic\n"
    },
    "react": {
      "name": "React",
      "description": "React 18+ with hooks, TypeScript, and modern patterns",
      "content": "# React Development Rules\n\nYou are an expert React developer. Follow these guidelines for all code generation.\n\n## Component Patterns\n\n- Use functional components exclusively (no class components)\n- Use TypeScript for all components\n- Keep components small and focused\n- Extract reusable logic into custom hooks\n- Use composition over prop drilling\n\n```tsx\ninterface ButtonProps {\n  variant: 'primary' | 'secondary';\n  children: React.ReactNode;\n  onClick?: () => void;\n}\n\nexport function Button({ variant, children, onClick }: ButtonProps) {\n  return (\n    <button className={`btn btn-${variant}`} onClick={onClick}>\n      {children}\n    </button>\n  );\n}\n```\n\n## Hooks\n\n- Follow the Rules of Hooks\n- Use `useState` for local state\n- Use `useReducer` for complex state logic\n- Use `useEffect` for side effects (with cleanup)\n- Use `useMemo` and `useCallback` sparingly (profile first)\n- Create custom hooks for reusable logic\n\n## State Management\n\n- Start with local state (useState)\n- Lift state only when needed\n- Use Context for global UI state\n- Use React Query/SWR for server state\n- Consider Zustand/Jotai for complex client state\n\n## Performance\n\n- Use React.memo for expensive pure components\n- Use lazy loading with React.lazy and Suspense\n- Virtualize long lists (react-window)\n- Profile before optimizing\n- Avoid inline object/function creation in render\n\n## File Structure\n\n```\ncomponents/\n├── Button/\n│   ├── Button.tsx\n│   ├── Button.test.tsx\n│   ├── Button.module.css\n│   └── index.ts\nhooks/\n├── useUser.ts\n├── useAuth.ts\n```\n\n## Testing\n\n- Use React Testing Library\n- Test user behavior, not implementation\n- Use `screen` queries\n- Prefer `userEvent` over `fireEvent`\n"
    },
    "vue": {
      "name": "Vue.js",
      "description": "Vue 3 with Composition API and TypeScript",
      "content": "# Vue.js Development Rules\n\nYou are an expert Vue.js developer. Follow these guidelines for all code generation.\n\n## Composition API\n\n- Use `<script setup>` syntax (Vue 3.2+)\n- Use Composition API over Options API\n- Use TypeScript for type safety\n- Extract reusable logic into composables\n\n```vue\n<script setup lang=\"ts\">\nimport { ref, computed } from 'vue'\n\ninterface Props {\n  initialCount?: number\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  initialCount: 0\n})\n\nconst count = ref(props.initialCount)\nconst doubled = computed(() => count.value * 2)\n\nfunction increment() {\n  count.value++\n}\n</script>\n\n<template>\n  <button @click=\"increment\">{{ count }} ({{ doubled }})</button>\n</template>\n```\n\n## Reactivity\n\n- Use `ref` for primitives\n- Use `reactive` for objects (but prefer `ref`)\n- Use `computed` for derived state\n- Use `watch` / `watchEffect` for side effects\n- Always access `.value` for refs in script\n\n## Component Design\n\n- Define props with TypeScript interfaces\n- Use `defineEmits` for type-safe events\n- Use `v-model` with `defineModel` (Vue 3.4+)\n- Keep templates clean and readable\n- Use slots for flexible composition\n\n## State Management\n\n- Use Pinia for global state\n- Define stores with Composition API syntax\n- Keep stores focused and modular\n\n## Best Practices\n\n- Use Single File Components (.vue)\n- Keep components small and focused\n- Use `<Suspense>` for async components\n- Use `<Teleport>` for modals/tooltips\n- Follow Vue style guide priority rules\n"
    }
  }
}
